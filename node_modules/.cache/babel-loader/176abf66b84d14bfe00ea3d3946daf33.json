{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\nvar globalDefaults = defaults.global;\ndefaults._set('global', {\n  elements: {\n    line: {\n      tension: 0.4,\n      backgroundColor: globalDefaults.defaultColor,\n      borderWidth: 3,\n      borderColor: globalDefaults.defaultColor,\n      borderCapStyle: 'butt',\n      borderDash: [],\n      borderDashOffset: 0.0,\n      borderJoinStyle: 'miter',\n      capBezierPoints: true,\n      fill: true // do we fill in the area between the line and its base axis\n    }\n  }\n});\n\nmodule.exports = Element.extend({\n  draw: function draw() {\n    var me = this;\n    var vm = me._view;\n    var ctx = me._chart.ctx;\n    var spanGaps = vm.spanGaps;\n    var points = me._children.slice(); // clone array\n    var globalOptionLineElements = globalDefaults.elements.line;\n    var lastDrawnIndex = -1;\n    var index, current, previous, currentVM;\n\n    // If we are looping, adding the first point again\n    if (me._loop && points.length) {\n      points.push(points[0]);\n    }\n    ctx.save();\n\n    // Stroke Line Options\n    ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n    // IE 9 and 10 do not support line dash\n    if (ctx.setLineDash) {\n      ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n    }\n    ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n    ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n    ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n    ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n    // Stroke Line\n    ctx.beginPath();\n    lastDrawnIndex = -1;\n    for (index = 0; index < points.length; ++index) {\n      current = points[index];\n      previous = helpers.previousItem(points, index);\n      currentVM = current._view;\n\n      // First point moves to it's starting position no matter what\n      if (index === 0) {\n        if (!currentVM.skip) {\n          ctx.moveTo(currentVM.x, currentVM.y);\n          lastDrawnIndex = index;\n        }\n      } else {\n        previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n        if (!currentVM.skip) {\n          if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {\n            // There was a gap and this is the first point after the gap\n            ctx.moveTo(currentVM.x, currentVM.y);\n          } else {\n            // Line to next point\n            helpers.canvas.lineTo(ctx, previous._view, current._view);\n          }\n          lastDrawnIndex = index;\n        }\n      }\n    }\n    ctx.stroke();\n    ctx.restore();\n  }\n});","map":null,"metadata":{},"sourceType":"script"}