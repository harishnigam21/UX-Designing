{"ast":null,"code":"import { PureComponent, createElement } from 'react';\nimport { array, func, number, oneOf, oneOfType, string } from 'prop-types';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = Object.setPrototypeOf || {\n  __proto__: []\n} instanceof Array && function (d, b) {\n  d.__proto__ = b;\n} || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = Object.assign || function __assign(t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n  return t;\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n}\nvar ALIGN_AUTO = 'auto';\nvar ALIGN_START = 'start';\nvar ALIGN_CENTER = 'center';\nvar ALIGN_END = 'end';\nvar DIRECTION_VERTICAL = 'vertical';\nvar DIRECTION_HORIZONTAL = 'horizontal';\nvar SCROLL_CHANGE_OBSERVED = 'observed';\nvar SCROLL_CHANGE_REQUESTED = 'requested';\nvar scrollProp = (_a = {}, _a[DIRECTION_VERTICAL] = 'scrollTop', _a[DIRECTION_HORIZONTAL] = 'scrollLeft', _a);\nvar sizeProp = (_b = {}, _b[DIRECTION_VERTICAL] = 'height', _b[DIRECTION_HORIZONTAL] = 'width', _b);\nvar positionProp = (_c = {}, _c[DIRECTION_VERTICAL] = 'top', _c[DIRECTION_HORIZONTAL] = 'left', _c);\nvar _a;\nvar _b;\nvar _c;\n\n/* Forked from react-virtualized ðŸ’– */\nvar SizeAndPositionManager = function () {\n  function SizeAndPositionManager(_a) {\n    var itemCount = _a.itemCount,\n      itemSizeGetter = _a.itemSizeGetter,\n      estimatedItemSize = _a.estimatedItemSize;\n    this.itemSizeGetter = itemSizeGetter;\n    this.itemCount = itemCount;\n    this.estimatedItemSize = estimatedItemSize;\n    // Cache of size and position data for items, mapped by item index.\n    this.itemSizeAndPositionData = {};\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this.lastMeasuredIndex = -1;\n  }\n  SizeAndPositionManager.prototype.updateConfig = function (_a) {\n    var itemCount = _a.itemCount,\n      estimatedItemSize = _a.estimatedItemSize;\n    this.itemCount = itemCount;\n    this.estimatedItemSize = estimatedItemSize;\n  };\n  SizeAndPositionManager.prototype.getLastMeasuredIndex = function () {\n    return this.lastMeasuredIndex;\n  };\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n  SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function (index) {\n    if (index < 0 || index >= this.itemCount) {\n      throw Error(\"Requested index \" + index + \" is outside of range 0..\" + this.itemCount);\n    }\n    if (index > this.lastMeasuredIndex) {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n      for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {\n        var size = this.itemSizeGetter(i);\n        if (size == null || isNaN(size)) {\n          throw Error(\"Invalid size returned for index \" + i + \" of value \" + size);\n        }\n        this.itemSizeAndPositionData[i] = {\n          offset: offset,\n          size: size\n        };\n        offset += size;\n      }\n      this.lastMeasuredIndex = index;\n    }\n    return this.itemSizeAndPositionData[index];\n  };\n  SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function () {\n    return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : {\n      offset: 0,\n      size: 0\n    };\n  };\n  /**\n   * Total size of all items being measured.\n   * This value will be completedly estimated initially.\n   * As items as measured the estimate will be updated.\n   */\n  SizeAndPositionManager.prototype.getTotalSize = function () {\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;\n  };\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n  SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function (_a) {\n    var _b = _a.align,\n      align = _b === void 0 ? ALIGN_START : _b,\n      containerSize = _a.containerSize,\n      currentOffset = _a.currentOffset,\n      targetIndex = _a.targetIndex;\n    if (containerSize <= 0) {\n      return 0;\n    }\n    var datum = this.getSizeAndPositionForIndex(targetIndex);\n    var maxOffset = datum.offset;\n    var minOffset = maxOffset - containerSize + datum.size;\n    var idealOffset;\n    switch (align) {\n      case ALIGN_END:\n        idealOffset = minOffset;\n        break;\n      case ALIGN_CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      case ALIGN_START:\n        idealOffset = maxOffset;\n        break;\n      default:\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n    }\n    var totalSize = this.getTotalSize();\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  };\n  SizeAndPositionManager.prototype.getVisibleRange = function (_a) {\n    var containerSize = _a.containerSize,\n      offset = _a.offset,\n      overscanCount = _a.overscanCount;\n    var totalSize = this.getTotalSize();\n    if (totalSize === 0) {\n      return {};\n    }\n    var maxOffset = offset + containerSize;\n    var start = this.findNearestItem(offset);\n    if (typeof start === 'undefined') {\n      throw Error(\"Invalid offset \" + offset + \" specified\");\n    }\n    var datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n    var stop = start;\n    while (offset < maxOffset && stop < this.itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this.itemCount - 1);\n    }\n    return {\n      start: start,\n      stop: stop\n    };\n  };\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n  SizeAndPositionManager.prototype.resetItem = function (index) {\n    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n  };\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n  SizeAndPositionManager.prototype.findNearestItem = function (offset) {\n    if (isNaN(offset)) {\n      throw Error(\"Invalid offset \" + offset + \" specified\");\n    }\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this.binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset: offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this.exponentialSearch({\n        index: lastMeasuredIndex,\n        offset: offset\n      });\n    }\n  };\n  SizeAndPositionManager.prototype.binarySearch = function (_a) {\n    var low = _a.low,\n      high = _a.high,\n      offset = _a.offset;\n    var middle = 0;\n    var currentOffset = 0;\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n    if (low > 0) {\n      return low - 1;\n    }\n    return 0;\n  };\n  SizeAndPositionManager.prototype.exponentialSearch = function (_a) {\n    var index = _a.index,\n      offset = _a.offset;\n    var interval = 1;\n    while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n      index += interval;\n      interval *= 2;\n    }\n    return this.binarySearch({\n      high: Math.min(index, this.itemCount - 1),\n      low: Math.floor(index / 2),\n      offset: offset\n    });\n  };\n  return SizeAndPositionManager;\n}();\nvar STYLE_WRAPPER = {\n  overflow: 'auto',\n  willChange: 'transform',\n  WebkitOverflowScrolling: 'touch'\n};\nvar STYLE_INNER = {\n  position: 'relative',\n  overflow: 'hidden',\n  width: '100%',\n  minHeight: '100%'\n};\nvar STYLE_ITEM = {\n  position: 'absolute',\n  left: 0,\n  width: '100%'\n};\nvar VirtualList = function (_super) {\n  __extends(VirtualList, _super);\n  function VirtualList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.sizeAndPositionManager = new SizeAndPositionManager({\n      itemCount: _this.props.itemCount,\n      itemSizeGetter: function itemSizeGetter(index) {\n        return _this.getSize(index);\n      },\n      estimatedItemSize: _this.getEstimatedItemSize()\n    });\n    _this.state = {\n      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n      scrollChangeReason: SCROLL_CHANGE_REQUESTED\n    };\n    _this.styleCache = {};\n    _this.handleScroll = function (e) {\n      var onScroll = _this.props.onScroll;\n      var offset = _this.getNodeOffset();\n      if (offset < 0 || _this.state.offset === offset || e.target !== _this.rootNode) {\n        return;\n      }\n      _this.setState({\n        offset: offset,\n        scrollChangeReason: SCROLL_CHANGE_OBSERVED\n      });\n      if (typeof onScroll === 'function') {\n        onScroll(offset, e);\n      }\n    };\n    _this.getRef = function (node) {\n      _this.rootNode = node;\n    };\n    return _this;\n  }\n  VirtualList.prototype.componentDidMount = function () {\n    var _a = this.props,\n      scrollOffset = _a.scrollOffset,\n      scrollToIndex = _a.scrollToIndex;\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  };\n  VirtualList.prototype.componentWillReceiveProps = function (nextProps) {\n    var _a = this.props,\n      estimatedItemSize = _a.estimatedItemSize,\n      itemCount = _a.itemCount,\n      itemSize = _a.itemSize,\n      scrollOffset = _a.scrollOffset,\n      scrollToAlignment = _a.scrollToAlignment,\n      scrollToIndex = _a.scrollToIndex;\n    var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n    var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n    if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n      this.sizeAndPositionManager.updateConfig({\n        itemCount: nextProps.itemCount,\n        estimatedItemSize: this.getEstimatedItemSize(nextProps)\n      });\n    }\n    if (itemPropsHaveChanged) {\n      this.recomputeSizes();\n    }\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setState({\n        offset: nextProps.scrollOffset || 0,\n        scrollChangeReason: SCROLL_CHANGE_REQUESTED\n      });\n    } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {\n      this.setState({\n        offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n        scrollChangeReason: SCROLL_CHANGE_REQUESTED\n      });\n    }\n  };\n  VirtualList.prototype.componentDidUpdate = function (_, prevState) {\n    var _a = this.state,\n      offset = _a.offset,\n      scrollChangeReason = _a.scrollChangeReason;\n    if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REQUESTED) {\n      this.scrollTo(offset);\n    }\n  };\n  VirtualList.prototype.getEstimatedItemSize = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;\n  };\n  VirtualList.prototype.getNodeOffset = function () {\n    var _a = this.props.scrollDirection,\n      scrollDirection = _a === void 0 ? DIRECTION_VERTICAL : _a;\n    return this.rootNode[scrollProp[scrollDirection]];\n  };\n  VirtualList.prototype.scrollTo = function (value) {\n    var _a = this.props.scrollDirection,\n      scrollDirection = _a === void 0 ? DIRECTION_VERTICAL : _a;\n    this.rootNode[scrollProp[scrollDirection]] = value;\n  };\n  VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {\n    if (scrollToAlignment === void 0) {\n      scrollToAlignment = this.props.scrollToAlignment;\n    }\n    if (itemCount === void 0) {\n      itemCount = this.props.itemCount;\n    }\n    var _a = this.props.scrollDirection,\n      scrollDirection = _a === void 0 ? DIRECTION_VERTICAL : _a;\n    if (index < 0 || index >= itemCount) {\n      index = 0;\n    }\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[sizeProp[scrollDirection]],\n      currentOffset: this.state && this.state.offset || 0,\n      targetIndex: index\n    });\n  };\n  VirtualList.prototype.getSize = function (index) {\n    var itemSize = this.props.itemSize;\n    if (typeof itemSize === 'function') {\n      return itemSize(index);\n    }\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  };\n  VirtualList.prototype.getStyle = function (index) {\n    var style = this.styleCache[index];\n    if (style) {\n      return style;\n    }\n    var _a = this.props.scrollDirection,\n      scrollDirection = _a === void 0 ? DIRECTION_VERTICAL : _a;\n    var _b = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n      size = _b.size,\n      offset = _b.offset;\n    return this.styleCache[index] = __assign({}, STYLE_ITEM, (_c = {}, _c[sizeProp[scrollDirection]] = size, _c[positionProp[scrollDirection]] = offset, _c));\n    var _c;\n  };\n  VirtualList.prototype.recomputeSizes = function (startIndex) {\n    if (startIndex === void 0) {\n      startIndex = 0;\n    }\n    this.styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  };\n  VirtualList.prototype.render = function () {\n    var _a = this.props,\n      estimatedItemSize = _a.estimatedItemSize,\n      height = _a.height,\n      _b = _a.overscanCount,\n      overscanCount = _b === void 0 ? 3 : _b,\n      renderItem = _a.renderItem,\n      itemCount = _a.itemCount,\n      itemSize = _a.itemSize,\n      onItemsRendered = _a.onItemsRendered,\n      onScroll = _a.onScroll,\n      _c = _a.scrollDirection,\n      scrollDirection = _c === void 0 ? DIRECTION_VERTICAL : _c,\n      scrollOffset = _a.scrollOffset,\n      scrollToIndex = _a.scrollToIndex,\n      scrollToAlignment = _a.scrollToAlignment,\n      style = _a.style,\n      width = _a.width,\n      props = __rest(_a, [\"estimatedItemSize\", \"height\", \"overscanCount\", \"renderItem\", \"itemCount\", \"itemSize\", \"onItemsRendered\", \"onScroll\", \"scrollDirection\", \"scrollOffset\", \"scrollToIndex\", \"scrollToAlignment\", \"style\", \"width\"]);\n    var offset = this.state.offset;\n    var _d = this.sizeAndPositionManager.getVisibleRange({\n        containerSize: this.props[sizeProp[scrollDirection]] || 0,\n        offset: offset,\n        overscanCount: overscanCount\n      }),\n      start = _d.start,\n      stop = _d.stop;\n    var items = [];\n    if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\n      for (var index = start; index <= stop; index++) {\n        items.push(renderItem({\n          index: index,\n          style: this.getStyle(index)\n        }));\n      }\n      if (typeof onItemsRendered === 'function') {\n        onItemsRendered({\n          startIndex: start,\n          stopIndex: stop\n        });\n      }\n    }\n    return createElement(\"div\", __assign({\n      ref: this.getRef\n    }, props, {\n      onScroll: this.handleScroll,\n      style: __assign({}, STYLE_WRAPPER, style, {\n        height: height,\n        width: width\n      })\n    }), createElement(\"div\", {\n      style: __assign({}, STYLE_INNER, (_e = {}, _e[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _e))\n    }, items));\n    var _e;\n  };\n  VirtualList.defaultProps = {\n    overscanCount: 3,\n    scrollDirection: DIRECTION_VERTICAL,\n    width: '100%'\n  };\n  VirtualList.propTypes = {\n    estimatedItemSize: number,\n    height: oneOfType([number, string]).isRequired,\n    itemCount: number.isRequired,\n    itemSize: oneOfType([number, array, func]).isRequired,\n    onItemsRendered: func,\n    overscanCount: number,\n    renderItem: func.isRequired,\n    scrollOffset: number,\n    scrollToIndex: number,\n    scrollToAlignment: oneOf([ALIGN_AUTO, ALIGN_START, ALIGN_CENTER, ALIGN_END]),\n    scrollDirection: oneOf([DIRECTION_HORIZONTAL, DIRECTION_VERTICAL]).isRequired,\n    width: oneOfType([number, string]).isRequired\n  };\n  return VirtualList;\n}(PureComponent);\nexport default VirtualList;","map":null,"metadata":{},"sourceType":"module"}