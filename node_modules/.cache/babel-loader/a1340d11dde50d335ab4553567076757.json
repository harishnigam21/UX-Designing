{"ast":null,"code":"import { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nimport { acos, asin, atan2, cos, degrees, radians, sin, sqrt } from \"./math\";\nfunction satelliteVerticalRaw(P) {\n  function forward(lambda, phi) {\n    var cosPhi = cos(phi),\n      k = (P - 1) / (P - cosPhi * cos(lambda));\n    return [k * cosPhi * sin(lambda), k * sin(phi)];\n  }\n  forward.invert = function (x, y) {\n    var rho2 = x * x + y * y,\n      rho = sqrt(rho2),\n      sinc = (P - sqrt(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1));\n    return [atan2(x * sinc, rho * sqrt(1 - sinc * sinc)), rho ? asin(y * sinc / rho) : 0];\n  };\n  return forward;\n}\nexport function satelliteRaw(P, omega) {\n  var vertical = satelliteVerticalRaw(P);\n  if (!omega) return vertical;\n  var cosOmega = cos(omega),\n    sinOmega = sin(omega);\n  function forward(lambda, phi) {\n    var coordinates = vertical(lambda, phi),\n      y = coordinates[1],\n      A = y * sinOmega / (P - 1) + cosOmega;\n    return [coordinates[0] * cosOmega / A, y / A];\n  }\n  forward.invert = function (x, y) {\n    var k = (P - 1) / (P - 1 - y * sinOmega);\n    return vertical.invert(k * x, k * y * cosOmega);\n  };\n  return forward;\n}\nexport default function () {\n  var distance = 2,\n    omega = 0,\n    m = projectionMutator(satelliteRaw),\n    p = m(distance, omega);\n\n  // As a multiple of radius.\n  p.distance = function (_) {\n    if (!arguments.length) return distance;\n    return m(distance = +_, omega);\n  };\n  p.tilt = function (_) {\n    if (!arguments.length) return omega * degrees;\n    return m(distance, omega = _ * radians);\n  };\n  return p.scale(432.147).clipAngle(acos(1 / distance) * degrees - 1e-6);\n}","map":null,"metadata":{},"sourceType":"module"}