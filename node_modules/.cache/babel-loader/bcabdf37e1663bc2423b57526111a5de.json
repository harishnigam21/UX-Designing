{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\ndefaults._set('global', {\n  elements: {\n    rectangle: {\n      backgroundColor: defaults.global.defaultColor,\n      borderColor: defaults.global.defaultColor,\n      borderSkipped: 'bottom',\n      borderWidth: 0\n    }\n  }\n});\nfunction isVertical(bar) {\n  return bar._view.width !== undefined;\n}\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param bar {Chart.Element.Rectangle} the bar\n * @return {Bounds} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar) {\n  var vm = bar._view;\n  var x1, x2, y1, y2;\n  if (isVertical(bar)) {\n    // vertical\n    var halfWidth = vm.width / 2;\n    x1 = vm.x - halfWidth;\n    x2 = vm.x + halfWidth;\n    y1 = Math.min(vm.y, vm.base);\n    y2 = Math.max(vm.y, vm.base);\n  } else {\n    // horizontal bar\n    var halfHeight = vm.height / 2;\n    x1 = Math.min(vm.x, vm.base);\n    x2 = Math.max(vm.x, vm.base);\n    y1 = vm.y - halfHeight;\n    y2 = vm.y + halfHeight;\n  }\n  return {\n    left: x1,\n    top: y1,\n    right: x2,\n    bottom: y2\n  };\n}\nmodule.exports = Element.extend({\n  draw: function draw() {\n    var ctx = this._chart.ctx;\n    var vm = this._view;\n    var left, right, top, bottom, signX, signY, borderSkipped;\n    var borderWidth = vm.borderWidth;\n    if (!vm.horizontal) {\n      // bar\n      left = vm.x - vm.width / 2;\n      right = vm.x + vm.width / 2;\n      top = vm.y;\n      bottom = vm.base;\n      signX = 1;\n      signY = bottom > top ? 1 : -1;\n      borderSkipped = vm.borderSkipped || 'bottom';\n    } else {\n      // horizontal bar\n      left = vm.base;\n      right = vm.x;\n      top = vm.y - vm.height / 2;\n      bottom = vm.y + vm.height / 2;\n      signX = right > left ? 1 : -1;\n      signY = 1;\n      borderSkipped = vm.borderSkipped || 'left';\n    }\n\n    // Canvas doesn't allow us to stroke inside the width so we can\n    // adjust the sizes to fit if we're setting a stroke on the line\n    if (borderWidth) {\n      // borderWidth shold be less than bar width and bar height.\n      var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n      borderWidth = borderWidth > barSize ? barSize : borderWidth;\n      var halfStroke = borderWidth / 2;\n      // Adjust borderWidth when bar top position is near vm.base(zero).\n      var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n      var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n      var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n      var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n      // not become a vertical line?\n      if (borderLeft !== borderRight) {\n        top = borderTop;\n        bottom = borderBottom;\n      }\n      // not become a horizontal line?\n      if (borderTop !== borderBottom) {\n        left = borderLeft;\n        right = borderRight;\n      }\n    }\n    ctx.beginPath();\n    ctx.fillStyle = vm.backgroundColor;\n    ctx.strokeStyle = vm.borderColor;\n    ctx.lineWidth = borderWidth;\n\n    // Corner points, from bottom-left to bottom-right clockwise\n    // | 1 2 |\n    // | 0 3 |\n    var corners = [[left, bottom], [left, top], [right, top], [right, bottom]];\n\n    // Find first (starting) corner with fallback to 'bottom'\n    var borders = ['bottom', 'left', 'top', 'right'];\n    var startCorner = borders.indexOf(borderSkipped, 0);\n    if (startCorner === -1) {\n      startCorner = 0;\n    }\n    function cornerAt(index) {\n      return corners[(startCorner + index) % 4];\n    }\n\n    // Draw rectangle from 'startCorner'\n    var corner = cornerAt(0);\n    ctx.moveTo(corner[0], corner[1]);\n    for (var i = 1; i < 4; i++) {\n      corner = cornerAt(i);\n      ctx.lineTo(corner[0], corner[1]);\n    }\n    ctx.fill();\n    if (borderWidth) {\n      ctx.stroke();\n    }\n  },\n  height: function height() {\n    var vm = this._view;\n    return vm.base - vm.y;\n  },\n  inRange: function inRange(mouseX, mouseY) {\n    var inRange = false;\n    if (this._view) {\n      var bounds = getBarBounds(this);\n      inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n    }\n    return inRange;\n  },\n  inLabelRange: function inLabelRange(mouseX, mouseY) {\n    var me = this;\n    if (!me._view) {\n      return false;\n    }\n    var inRange = false;\n    var bounds = getBarBounds(me);\n    if (isVertical(me)) {\n      inRange = mouseX >= bounds.left && mouseX <= bounds.right;\n    } else {\n      inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n    }\n    return inRange;\n  },\n  inXRange: function inXRange(mouseX) {\n    var bounds = getBarBounds(this);\n    return mouseX >= bounds.left && mouseX <= bounds.right;\n  },\n  inYRange: function inYRange(mouseY) {\n    var bounds = getBarBounds(this);\n    return mouseY >= bounds.top && mouseY <= bounds.bottom;\n  },\n  getCenterPoint: function getCenterPoint() {\n    var vm = this._view;\n    var x, y;\n    if (isVertical(this)) {\n      x = vm.x;\n      y = (vm.y + vm.base) / 2;\n    } else {\n      x = (vm.x + vm.base) / 2;\n      y = vm.y;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  },\n  getArea: function getArea() {\n    var vm = this._view;\n    return vm.width * Math.abs(vm.y - vm.base);\n  },\n  tooltipPosition: function tooltipPosition() {\n    var vm = this._view;\n    return {\n      x: vm.x,\n      y: vm.y\n    };\n  }\n});","map":null,"metadata":{},"sourceType":"script"}