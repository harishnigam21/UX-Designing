{"ast":null,"code":"var epsilon = 1e-4,\n  epsilonInverse = 1e4,\n  x0 = -180,\n  x0e = x0 + epsilon,\n  x1 = 180,\n  x1e = x1 - epsilon,\n  y0 = -90,\n  y0e = y0 + epsilon,\n  y1 = 90,\n  y1e = y1 - epsilon;\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\nfunction normalizePoint(y) {\n  return y === y0 || y === y1 ? [0, y] // pole\n  : [x0, quantize(y)]; // antimeridian\n}\n\nfunction clampPoint(p) {\n  if (p[0] <= x0e) p[0] = x0;else if (p[0] >= x1e) p[0] = x1;\n  if (p[1] <= y0e) p[1] = y0;else if (p[1] >= y1e) p[1] = y1;\n}\nfunction clampPoints(points) {\n  points.forEach(clampPoint);\n}\n\n// For each ring, detect where it crosses the antimeridian or pole.\nfunction extractFragments(polygon, fragments) {\n  for (var j = 0, m = polygon.length; j < m; ++j) {\n    var ring = polygon[j];\n    ring.polygon = polygon;\n\n    // By default, assume that this ring doesn’t need any stitching.\n    fragments.push(ring);\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n        x = point[0],\n        y = point[1];\n\n      // If this is an antimeridian or polar point…\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        clampPoint(point);\n\n        // Advance through any antimeridian or polar points…\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n            xk = pointk[0],\n            yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        }\n\n        // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n        if (k === i + 1) continue;\n\n        // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n        if (i) {\n          var fragmentBefore = ring.slice(0, i + 1);\n          fragmentBefore.polygon = polygon;\n          fragmentBefore[fragmentBefore.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        }\n\n        // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop();\n\n        // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n        if (k >= n) break;\n\n        // Otherwise, add the remaining ring fragment and continue.\n        fragments.push(ring = ring.slice(k - 1));\n        ring[0] = normalizePoint(ring[0][1]);\n        ring.polygon = polygon;\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n  polygon.length = 0;\n}\n\n// Now stitch the fragments back together into rings.\n// TODO remove empty polygons.\nfunction stitchFragments(fragments) {\n  var i,\n    n = fragments.length;\n\n  // To connect the fragments start-to-end, create a simple index by end.\n  var fragmentByStart = {},\n    fragmentByEnd = {},\n    fragment,\n    start,\n    startFragment,\n    end,\n    endFragment;\n\n  // For each fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment[0];\n    end = fragment[fragment.length - 1];\n\n    // If this fragment is closed, add it as a standalone ring.\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment);\n      fragments[i] = null;\n      continue;\n    }\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  }\n\n  // For each open fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    if (fragment) {\n      start = fragment[0];\n      end = fragment[fragment.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end];\n\n      // If this fragment is closed, add it as a standalone ring.\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment);\n        continue;\n      }\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment[0]];\n        startFragment.pop(); // drop the shared coordinate\n        fragments[startFragment.index] = null;\n        fragment = startFragment.concat(fragment);\n        fragment.polygon = startFragment.polygon;\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment[0]] = fragmentByEnd[fragment[fragment.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment[endFragment.length - 1]];\n        fragment.pop(); // drop the shared coordinate\n        fragment = fragment.concat(endFragment);\n        fragment.polygon = endFragment.polygon;\n        fragment.index = n++;\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment[0]] = fragmentByEnd[fragment[fragment.length - 1]] = fragment);\n      } else {\n        fragment.push(fragment[0]); // close ring\n        fragment.polygon.push(fragment);\n      }\n    }\n  }\n}\nfunction stitchFeature(o) {\n  stitchGeometry(o.geometry);\n}\nfunction stitchGeometry(o) {\n  if (!o) return;\n  var fragments, i, n;\n  switch (o.type) {\n    case \"GeometryCollection\":\n      {\n        o.geometries.forEach(stitchGeometry);\n        return;\n      }\n    case \"Point\":\n      {\n        clampPoint(o.coordinates);\n        break;\n      }\n    case \"MultiPoint\":\n    case \"LineString\":\n      {\n        clampPoints(o.coordinates);\n        break;\n      }\n    case \"MultiLineString\":\n      {\n        o.coordinates.forEach(clampPoints);\n        break;\n      }\n    case \"Polygon\":\n      {\n        extractFragments(o.coordinates, fragments = []);\n        break;\n      }\n    case \"MultiPolygon\":\n      {\n        fragments = [], i = -1, n = o.coordinates.length;\n        while (++i < n) extractFragments(o.coordinates[i], fragments);\n        break;\n      }\n    default:\n      return;\n  }\n  stitchFragments(fragments);\n}\nexport default function (o) {\n  if (o) switch (o.type) {\n    case \"Feature\":\n      stitchFeature(o);\n      break;\n    case \"FeatureCollection\":\n      o.features.forEach(stitchFeature);\n      break;\n    default:\n      stitchGeometry(o);\n      break;\n  }\n  return o;\n}","map":null,"metadata":{},"sourceType":"module"}